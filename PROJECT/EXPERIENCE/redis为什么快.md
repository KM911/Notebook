
## redis为什么快

我们在说明一个东西好时，应该指明其比较的对象，抛开了对比对象的特定性质，没有什么意义。
1.基于内存 

因为任何程序在运行的时候不都是存储在内存中吗？没有指代清楚对象。

这里的基于内存是指，redis将全部的数据存储到了内存里。传统的数据库是将全部的数据都存放到磁盘里，遇到查询操作时，将磁盘中的数据加载到内存中，再从内存中读取。写操作也是直接往内存中写，相比持久化到磁盘速度肯定快。 

2.数据类型比较简单

不会像一些业务很复杂的关系型数据库，多张表做联表查询这样的操作。虽然还是很多人将json往里怼，存储很多比较复杂的结构，这里我不认为是好的实践方式。



3.合适的持久化策略

redis也支持持久化，选则了合适的持久化策略才可以保证redis快，如果选则了每次增量写，我不认为redis还可以有很高的qps。 

4.单线程。

首先，不是多线程就一定比单线程快的。从指令上分析，单线程的指令是 执行逻辑 ， 多线程为了避免数据竞争等并发问题，需要频繁上锁释放锁操。 指令为 执行逻辑 + 锁操做 + 线程管理，你需要维护一个线程池吧。 如果当你的指令逻辑是非常简单的，就像我上面三点的所说的一样，因为单次操做是非常快的，可能和锁操作需要的时间是一致的，甚至我觉得是比锁操做要快的。 

这里可以引出锁的类型 三种操作系统提供的。

具体到代码，一个函数实现对一个变量进行自增操作。 如果不对其进行保护，多线程情况下，我们的自增操作也是不安全的，我们需要使用互斥锁来保护，也就是一个时间里只能有一个线程执行，我们的执行效率本身就没有提高，反而因为频繁上锁和释放锁严重拖累程序。尽然可以将读操作和写操作分开，这样又会带来一定程度的复杂度提升，性能提升也未必比单线程要好不少。

说回来，很多人说单线程避免了多线程的上下文切换从而性能好。这个如果真的是优点的话，那多线程就成为低性能的代表了。 
1. 服务器上通常不会只有一个程序，本身就存在大量的线程，其实即使只有一个线程，操作系统可能也会把时间片给idle线程而不是让你全部获取。100个线程和108个线程的上下文切换次数几乎没有差别。

2. 上下文切换的开销其实是不大的，只是这部分的开销是额外的开销，就显得很多了，就像上面的自增操作中的锁操作一样。因为其实就只需要恢复寄存器的状态就好了，其实是可以一次设置多个寄存器的值，不然循环展开就不可能作为一种常见的函数优化手段了。 

3. 上面的内存自己去写。 合理的单线程程序未必就差。 

计算机的世界里没有银弹（最优秀的方法），更多的时候需要你trade off （权衡）。 你需要根据合适的业务做 合适的 取舍，根据实际的场景，才有好和坏。 就像我们都说 快排 很快，但是如果我告诉你数组只有几个元素是乱序的，快排还一定快吗？ 未必了吧。我觉得冒泡都可以有不错的效率。


## 有了DMA，异步IO才是有意义。

正常情况下，即使有DMA，我们的程序也不会

发出IO请求 -> 让出CPU 等待IO完成 -> IO完成，操作系统让程序进入等待队列

### DMA ( Direct Memory Access )

直接存储器访问


它允许某些电脑内部的硬件子系统（电脑外设），可以独立地直接读写系统内存，而不需中央处理器（CPU）介入处理 。在同等程度的处理器负担下，DMA是一种快速的数据传送方式。很多硬件的系统会使用DMA，包含硬盘控制器、绘图显卡、网卡和声卡。

通俗来说  就是在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给DMA控制器，而CPU 不再参与任何与数据搬运相关的事情，这样CPU 就可以去处理别的事务。




