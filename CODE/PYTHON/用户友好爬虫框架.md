---
file-created: 2023,11,08
last-modified: 2023,11,25
---

我们今天致力于实现一个用户友好的爬虫框架解决如下问题. 

1. 功能模块解耦 就像scrapy一样,但是没有必要过于复杂
2. 实现断点续传的功能 
3. python的多线程
4. 更加友好的提示信息

--- 

### 功能demo
- [x] 进度条
- [x] yeild
- [x] sqlite数据持久化
- [ ] 架构设计
- [ ] 结构化数据是否会影响性能

---

#### 进度条

利用rich这个库实现
```python
import time

from rich.progress import Progress

with Progress() as progress:

    task1 = progress.add_task("[red]Downloading...", total=1000)
    task2 = progress.add_task("[green]Processing...", total=1000)
    task3 = progress.add_task("[cyan]Cooking...", total=1000)

    while not progress.finished:
        progress.update(task1, advance=0.5)
        progress.update(task2, advance=0.3)
        progress.update(task3, advance=0.9)
        time.sleep(0.02)
```
---

### python yeild

genertor function 

it was a special function next just like iterator ? 

---
### python string test

这里其实是对于大量的结构化字符串,因为其中存在大量的字符
一个字符串其实就只有1kb 就算是1k个也才1mb的内存使用,这不过是几个res的内容罢了. 

---
## gevnet使用教程

---
### Python中的with语句

这里是一个语法糖,我们实现一个也支持with语法的就可了解其实现了. 
一般用得最多的地方其实是文件读写的部分是吗? 

```python
class Myfile:
  def __init__(self,filename) -> None:
    print("init")
    self.file = open(filename,"w",encoding="utf-8")
  def __enter__(self):
    print("enter")
    return self
  def __exit__(self, exc_type, exc_val, exc_tb):
    print(exc_type,exc_val,exc_tb)
    print(type(exc_type),type(exc_val),type(exc_tb))
    self.file.close()

if __name__ == '__main__':
    with Myfile("test.txt") as  f:
      print(f)
```

实现 __enter__ 和 __exit__ 方法, 其中enter方法需要返回self,当然其实也可以不返回,这样就无法操作该对象了. 两个效果完全等价不是吗?
```python
def OPEN(filename):
  return Myfile(filename)

if __name__ == '__main__':  
    with OPEN("test.txt") as  f:
      print(f)

```

其实你也可以实现增强功能的,这样还是很有意义的不是吗? 

## 反思

1. gevent好像本质并没有实现"协程" 你懂的意思吗? 
2. python的Ctrl+C是在当前位置触发一个error, try会导致其无法退出
3. 其实代码好像做了半天就是在脱裤子放屁了

python的原理又懂了,看来还是不错的