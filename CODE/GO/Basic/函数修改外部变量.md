---
file-created: 2023 11 15
last-modified: 2023 11 29
---



直接修改全局变量 好像也是一种方法 不过全局变量 不是那么安全 任何函数都可以修改 

想到了一个傻的问题,对于我们的C语言来说,如果想在函数比如说修改某个变量的值同时知晓是否修改成功,可以使用这样的方式.
将返回值作为错误处理的一部分,利用指针来修改值. 完了,突然发现我好像不会利用C语言进行错误处理.或者说C语言的错误处理很"机器",以函数返回-1或者NULL这样为代表(例如打开文件失败 `fp==NULL` 

```c
int modifie(int* v){}
```

## 如何才可以 

通常情况下 我们知道变量有两种类型 一种是基本类型(basic type) 另一种是引用类型(reference type)可以理解为指针.

但是如果考虑到结构体和类,事情就复杂起来了,不同的编程语言具体的实现可以回有所不同,我们还是自己亲自动手试试看,为了避免以后踩坑.


## 实验涉及

go语言的变量类型分类

basic type : int bool
reference type : slice map string
struct  someone say it is basic type someone not 
interface it like the vitural class in C++
function function is also a argv and maybe it could change some variable.

Do they have pointer type? Maybe you should write more test to prove your point. 

### example 

disadvantage : 
unfriendly hint info  
benchmark analyse

```go
// 函数传值
func AddBB(x int) {
	x++
}

func AddBR(x *int) {
	*x = *x + 1
}

func AddRB(x []int) {
	x[0]++
}
func AddRR(x *[]int) {
	(*x)[0] = (*x)[0] + 1

}

func AddXB(x X) {
	x.value++
}

func AddXR(x *X) {
	x.value++

}

func AddMapB(m map[int]int) {
	m[0]++
}
func AddMapR(m *map[int]int) {
	(*m)[0]++
}

type X struct {
	value int
}

func TestAdd(t *testing.T) {
	t.Run("bb", func(t *testing.T) {
		x := 0
		AddBB(x)
		if x != 1 {
			t.Error("")
		}
	})

	t.Run("br", func(t *testing.T) {
		x := 0
		AddBR(&x)
		if x != 1 {
			t.Error("")
		}

	})

	t.Run("rb", func(t *testing.T) {
		x := []int{0}
		AddRB(x)
		if x[0] != 1 {
			t.Error("")
		}

	})

	t.Run("rr", func(t *testing.T) {
		x := []int{0}
		AddRR(&x)
		if x[0] != 1 {
			t.Error("")
		}
	})

	t.Run("struct rb", func(t *testing.T) {
		x := X{value: 0}
		AddXB(x)
		if x.value != 1 {
			t.Error("")
		}
	})

	t.Run("sttruct rr", func(t *testing.T) {
		x := X{value: 0}
		AddXR(&x)
		if x.value != 1 {
			t.Error("")
		}
	})

	t.Run("map b", func(t *testing.T) {
		x := map[int]int{0: 0}
		AddMapB(x)
		if x[0] != 1 {
			t.Error("")
		}
	})
	t.Run("map r", func(t *testing.T) {
		x := map[int]int{0: 0}
		AddMapR(&x)
		if x[0] != 1 {
			t.Error("")
		}
	})
}

```