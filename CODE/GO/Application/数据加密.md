
## 如何避免数据泄露 

>[!others] 因为我需要将我们的笔记分享到网上,所以笔记上就不能存在例如账号密码之类的隐私信息.


>[!done] 为其编写一个加密软解 

>[!tip] 总体流程 
>1.使用[Execute Code](Execute%20Code.md) 执行 lean 代码 , 然后就可以生成真实的


## 对称加密算法 

>[!note] 凯撒密码 

输入格式 : a-z 26个小写字符 
加密原理 : 将字符集进行整体移动 例如移动3位 a--> d d--> k 
>[!exp] 代码实现  
> ```python
> def caesar_encrypt(text, shift):
>     result = ""
>     for i in range(len(text)):
>         char = text[i]
>         if char.isalpha():
>             ascii_offset = ord('a') if char.islower() else ord('A')
>             encrypted_char = chr(
>                 (ord(char) - ascii_offset + shift) % 26 + ascii_offset)
>             result += encrypted_char
>         else:
>             result += char
>     return result
> 
> 
> text = "a hello world"
> shift = 3
> print("原始文本: " + text)
> print("移动位数: " + str(shift))
> print("加密后的文本: " + caesar_encrypt(text, shift))
> print("解密后的文本: " + caesar_encrypt(caesar_encrypt(text, shift),-1*shift))
> ```

>[!tip ] 想要获取原始字符串就将 移动值设置为负数

### 思想才是最重要的不是吗? 

### 基于Unicode的凯撒密码 

输入格式 : 任意字符串 
加密原理 : 同上,不过字符集变成了Unicode


> [!exp] 代码实现
> ```python
> def caesar_encrypt_unicode(text, shift):
>     result = []
>     for i in range(len(text)):
>         result.append(chr((ord(text[i]) + shift) % 65536))
>     return "".join(result)
> 
> text = "a hello 中文测试 特殊字符!@#$%^"
> shift = 3
> print("原始文本: " + text)
> print("移动位数: " + str(shift))
> print("加密后的文本: " + caesar_encrypt_unicode(text, shift))
> print("解密后的文本: " + caesar_encrypt_unicode(caesar_encrypt_unicode(text, shift), -shift))
> ```
> 


### 添加复杂度 

>[!warning] 我们这个加密算法目前还不够复杂,通过暴力破解很快就可以被解决了. 

>[!note] 我打算从shift来做文章 
>shift值改为通过`username` 计算得到,并且会根据 `username` 修改字符集的对应关系. 

>[!example] 测试结果
>加密
>```groovy
>hello 我是加密字符串
>```
>解密
>
>```groovy
>׉׆׍׍אց杲殐堁愧悸肇厓ա
>```


