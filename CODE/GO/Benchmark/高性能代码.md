
## 避免内存分配
这里还没有比较多次内存分配和一次分配大内存的区别,不过其实也是一样的,你如果知道内存对齐的话,肯定还是大内存分配要好得多.


我们知道函数式编程原则上应该编写纯函数,但是这是效率十分低下的.以map函数为例,我分别实现了三种不同的.

````col
```go
// 纯函数 返回一个全新的切片
func Map[T, R any](array []T, callback func(T) R) []R {
	result := make([]R, len(array))
	for i := 0; i < len(array); i++ {
		result[i] = callback(array[i])
	}
	return result
}

```

```go
//  同样是纯函数,不过没有提前分配内存
func MapAppend[T, R any](array []T, callback func(T) R) []R {
	var result []R
	for _, value := range array {
		result = append(result, callback(value))
	}
	return result
}
```

```go
// 利用原始数组的空间 
func MapSameType[T any](array []T, callback func(T) T) []T {
	for i := 0; i < len(array); i++ {
		array[i] = callback(array[i])
	}
	return array
}

```
````

#### Benchmark测试数据
其实不用猜都可以知道,肯定是利用原始切片空间的方法最快.不过比较意外的是使用函数式编程和普通的for循环的性能是一样的.所以你需要在特定的场景下使用,而不是无脑吹某一种,不过确实没有看到append有什么作用.
```go
BenchmarkMap
BenchmarkMap-12                 14018985                86.64 ns/op           51B/op          4 allocs/op
BenchmarkMapAppend
BenchmarkMapAppend-12            7745492               159.4 ns/op           115B/op          6 allocs/op
BenchmarkMapSameType
BenchmarkMapSameType-12         100000000               11.27 ns/op            0B/op          0 allocs/op
BenchmarkMapFor
BenchmarkMapFor-12              14112865                83.45 ns/op           51B/op          4 allocs/op
```


## 函数内联



这里我就没懂为什么有的时候是需要你去对一个对象传地址,我就有点没明白不是没? 
## 引用传递
这里其实大部分编程语言都一样,对于普通的数据类型采用Copy value ,大对象传引用, 所以这些类型就有了第二个名字,引用类型.
性能对比分析测试可以开始编写了.

