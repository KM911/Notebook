


## 高性能手册

​	很多人都说自己的代码是高性能(high performance),但是都是从理论的角度做一些分析.我时常会想,如果提供一些benchmark,既可以让我们直观性能差距,也为自己的高性能留下了一份证据.

​	很可惜,尽管go提供了非常方便的benchmark,但是很多情况下,并没有人提供具体的数据,既然如此,我们就写一个手册吧.


## sheet

[[RPC比HTTP要慢]]
[[gorm性能对比]]
[[go语言并发实践]]
[[go bench|go bench]]





## 日志

​		相较于将直接将信息输出,利用日志可以获取更好的性能. 因为不需要渲染到屏幕上.

在windows上想要打开一个稍大的文本文件其实是做不到的.这样有点垃圾了就是说.不过其实都差不多,只要是想查看全部文件都最好是利用



至少在这里我们可以就确认一件事情,我们可以利用

一次写入大量日志 和 分多次写入 

哪一个的性能会更好呢? 我觉得是这样的,一次写入大量内容,可以开辟连续的磁盘空间,写入效率肯定是要高于分多次写入,并且由于最小存储单元是block,不同的操作系统会有差异,windows可能会新开辟一个cluster,而不是将其合并

发现了一个大问题了,哈哈哈哈 其实就是

567,633,551 

567,672,832

39,281Byte 也就是浪费了 30多kb的磁盘空间 不过考虑到碎片率其实不是很高,只有万分只几的内存空间.





### 日志文件的大小是否会影响写入速度

有但是不关键 我其实还是推荐到没有过

```go
func BenchmarkLogPrintln(b *testing.B) {
 lg.StartSimpleLog("log.log")
 for i := 0; i < b.N; i++ {
  log.Println("hello world")
 }
}
func BenchmarkLogPrintlnNewFile(b *testing.B) {
 lg.StartSimpleLog("newlog.log")
 for i := 0; i < b.N; i++ {
  log.Println("hello world")
 }
}
```

log.log以提前写入1GB的数据文件,newlog.log是空文件.两者几乎没有性能差距.

这里其实也好理解,因为追加写入模型,并不需要读取文件本身.再加上windows会直接开辟新的cluster,而不是尝试将内容合并后重新写入.这样就会导致对于操作系统来说,其实都是写入了相同的内容.

不过日志文件的大小很影响我们查询的效率,比如利用 `cat`将会花费更多的时间.

个人认为在SSD上日志文件最好不要超过500MB,HHD上不要超过100MB,不然其实不是很好查询信息.


```
BenchmarkLogPrintln
BenchmarkLogPrintln-12                    291366              4129 ns/op
BenchmarkLogPrintlnNewFile
BenchmarkLogPrintlnNewFile-12             277338              4101 ns/op
```



### fmt.Println vs log.Println 

这里其实可以直接猜出答案,就是肯定写入日志的速度要快得多.主要是想看看具体的差距,可以看见,花费的时间大概相差一个数量级,所以我们以后还是使用日志代替我们的print输出吧.

go 的printf是线程安全的,因为要上锁,所以性能其实是很差劲的.

```go
BenchmarkPrintln-12        28903             40935 ns/op
BenchmarkLogPrintln-12                    291366              4129 ns/op
```



### 避免多次写入









## 函数





## 结构体





## goroutine



## 字符串处理





