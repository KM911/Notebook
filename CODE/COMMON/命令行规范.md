
## 做好一件事是非常困难的 

写一个命令行工具 其实是非常困难的.你可以写出来,但是可能只有基本功能,甚至连基本的功能都没有实现.



## 命令行规范

```bash
[ELF] [flags ...] [argvs ...]
``` 

###  flag and flag value

这里关于的是我们的bool类型 , 如果没有,就是false,不进行行为,有才是true 执行行为, 总是执行"最小"功能. 

falg = 这样的也不是好文明?


所以说 go的命令行解析 不是什么好的文明. 

其实一个命令行框架没有多少内容不是吗 ? 

看你怎么想了 主要还是自己使用 比较有意义.


当命令的调用没有传入任何 option 时, 或者用户输入 -h, 或 --help 时, 显示帮助文本。

默认显示精简的帮助文本。

精简的帮助文本应该只包含:

有关程序功能的说明。
一到两个调用示例。
选项的描述，除非有很多选项。
提示通过 --help 可以获取更多信息。

这里对于需要从pipe读取的命令行工具就不是那么规范了

## demo 实例 

我还是比较喜欢我们的gcc版本. 

1. flag 和 argv的顺序不会有影响  好的特性 这样增强了cli软件的鲁棒性 是非常好的设计.
```bash
gcc main.c -E -o main.i 
gcc -E -o main.i main.c 
```

反面例子, go的flag库.
如果你将flag放到后面,会将其视为argv,不好的设计.
2. 不同类型的flag变量,布尔,string,数值. 
这里有两种风格,如果你都可以支持那我只能说是再好不过了,如果只能支持一种,请提前说明.
这里还有关于如果给bool类型的flag传值. 
xxx=true xxx=false 感觉比较愚蠢,一种好的方法是,默认为false,如果特别申明了该flag,改flag就为true. 

主要是可以减少用户需要键入的内容,这样不仅可以提高我们的使用体验.好的名字也是非常重要的 



不过问题来了,这里的 true和false其实是两位一体的. 有的人觉得错误信息很关键,所以默认是打开stderr的,需要 --no-error 去屏蔽错误信息,有的人觉得错误信息会影响体验,默认是关闭的,需要手动打开. 这里又是讨论一番的事情了.
我个人认为,始终保持"最小功能",默认只执行最简单的功能,想要添加其他的功能,需要你去显式申明. 

比如string 类型的参数传递就应该利用 空格然后第二给个输入 而不是=号.
理由: 等号相对来说比较麻烦,你的小拇指需要运动非常远的距离,这样的键入体验不是很好,如果你的.


```bash
gcc main.c -E -o=main.i  # 这样会生成一个 =main.i文件 只能说是有鲁棒性 但是不是非常鲁棒 如果你不支持`=` 就应该给出提示,避免用户产生疑惑.
```

## 目前看来 好像clap是全部都支持的  = 和   value的形势 我称之为好的设计. 是非常不错的. 

这样的事情可简单多了 不是吗?


## 逆天文件设计?

猜猜看,在一个目录下是否可以创建两个文件或者文件夹,他们的名字分别为 `TEST` 和`test` 或者是任意形式的大小写组合.

我本人测试的时候发现,文件系统会将其视为同一个文件导致无法创建. 

这样是好的设计吗? 文件系统不区分文件的大小写. 并且是完全不区分,但是显示的时候又会区分大小写.

有两种情况,比如你像cd到一个文件夹,不严格区分大小写,可以视为鲁棒性很强,好的设计.可是问题在于我们的程序就不应该在这样的. 

导致我在编写一个程序的时候出现了问题.
