
>[!note] 让我们完全记录一下 这门课程所讲授的全部知识吧 . 


>[!note] 一些吐槽 
>1. 虽然理论上来说这门是一个 `Meta` 的课程,不依赖任何编程语言而独立存在,但是实际上,为了帮助大家理解,我们还是需要依赖到某一门具体的编程语言上,然后的人就会将`ML`的内容视为"圭臬". 
>2. 所以你应该可以将其中更为重要的内容 "剥茧抽丝". 

说实话,这门课可以更加简洁并且更加贴合真实的代码问题就完美了,天天看 add , sum, fib 这些,我并不认为你的代码水平可以有任何的提高不是吗? 


不会更新

该课程只涉及前两章的内容. 


3. expressions and variables 
4. rules of expressions
5. REPL and errors
6. shadowing
7. function informally
8. function formally
9. tuples
10. lists
11. list function
12. let expression : create a temp variable
13. nested function
14. let efficiency
15. options 
16. booleans
17. no mutation
18. java mutation
19. language pieces : syntax semantics Idioms libraries tools
20. build new types
21. records (a special ) 其实就是字典吗
22. tuples 
23. datatyep_bindings   : user define data type 
24. case_expressions : 根据变量类型 的if条件语句
25. useful datatypes
26. precise pattern matching sofar
27. type synonymous : 完全等价于 C语言的typedef
28. another expression example
29. list and option datatype
30. polymorphic datatype
31. each of pattern matching
32. type inference
33. polymorphic and equality tyes
34. nested patterns
35. more nested patterns
36. nested patterns precisely
37. function patterns
38. exceptions
39. tail recursion
40. accumulator 特别指代tail recursion 中的result 
41. tail recursion perspective
42. functions intro
43. functions as arguments
44. functions and types
45. anonymous functions
46. unnecessary function wrapping
47. map and filter 函数式编程的核心 opertor high order function
48. generalizing prior topic 柯里化内容
49. lexical scope
50. lexical scope and function 主要是为了给后面的函数闭包做准备
51. why lexical scope
52. closures and recomputation
53. fold and mroe closures
54. combing functions
55. currying
56. partial application
57. currying warp up
58. mutable reference 指针修改常量
59. callbacks 
60. library docs
61. adts with closures
62. without closures
63. java without closures
64. c without closures
65. section introduction
66. what is type inference
67. ml type inference
68. type inference example
69. polymorphic example
70. other inference
71. mutual recursion
72. namespace mgmt
73. signatures 
74. module example
75. signature for examples
76. signature matching
77. equivalent structure
78. another equivalent structure
79. modules different types
80. function equivalence
81. standard equivalence
82. equivalence performance
83. racket intro
84. racket lists
85. racket lists
86. syntax and parens
87. parens matter
88. dynamic typing
89. cond
90. local bindings
91. top level binding
92. setbang
93. truth about cons
94. mcons
95. thunks 
96. avoid computations
97. delay and force
98. using streams
99. defining streams 
100. memorization
101. macros intro
102. three issues
103. define syntax
104. hygiene
105. macro example
106. section topics
107. datatypes without structs
108. datatype  with structs
109. why structs
110. implement a language
111. interpreter assumption 
112. implement variables
113. implement closures
114. 

## Core Concept 

variable part
[[expression]]
[[CARD/BOOK/ProgrammingLanguage/Variable|Variable]]
[[lexical_scope]]
[[CARD/BOOK/ProgrammingLanguage/variable/Shadow]]
[[tuple list]]
[[function]]
[[nested_function|nested_function]]
[[option]]
[[boolean]]
[[dictionary]] [[map]]
[[mutation]]

[[exceptions]] 或者说是 error 


user define part variable part

function part 
[[function]]
[[inline function]]
[[recursion]]
[[tail_recursion]]

[[function as argument]]
[[anonymous functions]]







| English | 美式发音的示例 |
| --- | --- |
| temporary | <audio controls="controls" preload="none" src="http://dict.youdao.com/dictvoice?type=0&audio=temporary"></audio> |

