---
file-created: 星期六, 十一月 ,2023
last-modified: 星期日, 十一月 ,2023
---
>[!faq] 问题 
>程序持有文件时，其他程序可以修改吗？

>[!done] 结论
>可以！
>如何不想其他程序修改，需要自己上文件锁,最下面有实现代码

>[!note] 操作
>
> 我先后启动两个脚本，在我 Ctrl+C 的时候才关闭文件。
> 在没有中断的时候，python肯定是持有这个文件的，不信你删除Test.txt, 看操作系统报的信息。
> 
> 既然已经在python中打开，那我再次启动一个python程序，它居然没有任何异常情况。
> 
> 那是不是说明 "程序持有文件时，其他程序可以修改"
>

>[!bug] 奇怪?
> 在python 程序执行过程之中，我是用记事本打开该文件，写。
> 保存的时候，提示我要保存的位置！
> 但是python程序不执行时，你就可以直接保存。
> 记事本 本身就是一个进程
> 

>[!note] 其他尝试
我还尝试使用多线程来测试，是否会出现混乱的写入（结果穿插的写入），最后写下来，没有发现令我耳目一新的结果。
写入操作是原子操作，即使你多个线程操作同一个文件，最终文件的内容也就是执行最慢的那个线程写入的内容。
感觉做了个寂寞。

如有错误，请批评。



### 测试用代码

```python
fp = open('Test.txt', 'w')

fp.write('Hello Follow\n')
fp.flush()

print('Follow: Hello World\n')

while 1:
    try:
        pass
    except KeyboardInterrupt:
        fp.close()
        print('KeyboardInterrupt')
        break
```

```python
fp = open('Test.txt', 'w')

fp.write('Hello worker1\n')
fp.flush()
print('worker1: Hello World\n')

while 1:
    try:
        pass
    except KeyboardInterrupt:
        fp.close()
        print('KeyboardInterrupt')
        break

```
#### 上锁版本
```python
import portalocker


fp = open('Test.txt', 'w')
portalocker.lock(fp, portalocker.LOCK_EX)
fp.write(f'Hello worker\n')
print(f'worker: Hello World\n')
fp.flush()

try:
    while 1:
        pass
except KeyboardInterrupt:
    fp.close()
    print('KeyboardInterrupt')
    pass

```

ok,你把上面的代码启动起来，然后再使用另一个python程序访问，应该会报 p...deny。

我是这样实现的，一直等待文件释放,这样应该能更好的说明，我们加锁之后的版本别人不可以 "修改"，甚至 只读 都被拒绝。

```python
def open_file():
    fp = open('Test.txt', 'w')

    fp.write('Hello Follow\n')
    fp.flush()

    print('Follow: Hello World\n')

    fp.close()


while 1:
    try:
        open_file()
        break
    except:
        pass

```

