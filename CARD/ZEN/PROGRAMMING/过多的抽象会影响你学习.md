
> Abstraction is good , but not Englis和.

## 一个问题

有一个问题常常被人们所讨论--将什么语言作为你的第一门编程语言?

很多人都认为是python,因为它比较"简单",上手难度比较小,适合大一新生和小朋友.

我并不反对将python作为第一名语言,恰恰相反,我觉得入门就是应该越简单越好,如果一开始就是非常抽象难以理解的概念,海量的符号,可以把大多数人劝退,然后丧失了学习的兴趣. 

但是如果你企图通过学习python来细节计算机的底层细节,我不认为这是可行的.你已经路径依赖,你觉得哪些方法就是集成在一起的,你会觉得哪些库函数美妙极了,几乎所有问题都可以通过引入一个包,然后调用其中的几个方法,就可以解决你的问题.

## FILE 对象

下面是一段常见的python文件读取操作.功能是读取某个文件的第一行并输出.
```python
file = open("test.txt","r")
print(file.readline())
```

这看上去非常"简单"和"容易",你还可以利用file.readlines()方法,一次将全部的文件都按照行来读取出来.

让我们重新审视一下文件吧,readline是如何刚好读取一行的内容的呢?是操作系统提供的接口?还是我们可以直接知道换行符的位置?

python将许多繁琐的内容为你屏蔽了,以至于你几乎从来没有思考过这些问题,这样是很不好的,特别是当你需要做一些底层的操作时.

## 一个实现

我们应该知道,我们的程序不可能真的是恰好读了一整行的内容.

实际上它的实现可能是这样的.

`````col
````col-md
flexGrow=1
===
```go
package main

import (
	"fmt"
	"os"
	"strings"
)

func main() {
	file, err := os.Open("test.txt")
	if err != nil {
		return
	}
	defer file.Close()
	buffer := make([]byte, 10)
	//file.Read(buffer)
	line := strings.Builder{}
	for {
		n, err := file.Read(buffer)
		if err != nil {
			break
		}
		if IndexWrap(buffer) != -1 {
			line.Write(buffer[:IndexWrap(buffer)])
			println(line.String())
			line.Reset()
			// 从换行符的下一个字节开始写入
			line.Write(buffer[IndexWrap(buffer)+1 : n])
		} else {
			line.Write(buffer[:n])
		}
		// check buffer 中是否有\n 换行符
	}
	fmt.Println(line.String())
}

// 换行符的byte值是10
func IndexWrap(buffer []byte) int {
	for i, v := range buffer {
		if v == 10 {
			return i
		}
	}
	return -1
}
`````

为什么我们需要学习一些底层的语言,我们才可以真正意义上的理解和认识计算,而不是认为真的可以按照行读取,这太不可思议了.


或者我们可以面向对象一点点.主要是C语言没有办法利用 obj.method() 这样的形式去调用函数.

```go
type File struct {
	fd         *os.File
	buffer     []byte
	lineBuiler strings.Builder
}

func NewFile(filename string) (*File, error) {
	fd, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	return &File{fd: fd, buffer: make([]byte, 8)}, nil
}
func (f *File) ReadLine() string {
	for {
		n, err := f.fd.Read(f.buffer)
		if err != nil {
			return ""
		}
		if IndexWrap(f.buffer) != -1 {
			f.lineBuiler.Write(f.buffer[:IndexWrap(f.buffer)])
			line := f.lineBuiler.String()
			f.lineBuiler.Reset()
			f.lineBuiler.Write(f.buffer[IndexWrap(f.buffer)+1 : n])
			return line
		} else {
			f.lineBuiler.Write(f.buffer[:n])
		}
	}
	return ""
}

// 换行符的byte值是10
func IndexWrap(buffer []byte) int {
	for i, v := range buffer {
		if v == 10 {
			return i
		}
	}
	return -1
}

func main() {
	file, err := NewFile("test.txt")
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(file.ReadLine())
	fmt.Println(file.ReadLine())
	fmt.Println(file.ReadLine())
}

```

上面的代码并不完全正确,比如当字符编码为UTF-8将会出现问题,我是通过判断换行符的ASCII码值;如果长度为10的buffer读取到了多个换行符.

我们会发现,文件读取其实有非常多的可以权衡的地方,比如一次应该从文件中读取多少byte?是否需要考虑编码问题?提供一个readline方法是有必要的吗?

## 水稻是从超市里长出来的

这里一句笑话,特指哪些在城市长大的小孩子,长期生活在现代化的都市里,从来没有去过乡村,没有见过在田里的水稻,因为一直都是在超市里买的水稻.

长期在高度抽象层的我们也是一样的,学python的很多人一直觉得创建了变量就可以不用管了,不知道垃圾回收机制帮助了它,我们还是需要学习最底层的部分.
