
## no free lunch

> 很多人喜欢讨论何种编程语言好/性能高,且不说是否真的存在A语言对B语言存在全面性的领先,至少我们知道,大部分人并非真的是PL界的先锋,也不是真的想从辩论中学到什么,只是想通过论证前者,来推出使用该编程语言的自己所编写的程序好/性能高. 

不过很不幸的是, 人和人之间的差别比编程语言之间的差别要多得多. 

回归主题. no free lunch -- 没有白送的好事,也没有"白费"的功夫. 

### 1. garbage collection vs manual memory management 垃圾回收 和 手动内存管理 

>[!warning] 有垃圾回收 != 不会内存泄露 
>有一种非常搞笑的观点是, 只要xx编程语言有了垃圾回收就不会出现内存泄露. 

>[!others] 通常语境下的内存泄露是手动申请的内存忘记释放或者无法释放(例如在free前将指针赋值为NULL). 这里内存泄露表示内存占用会不合理地增长. 

>[!exp] 
>全局变量因为其作用域是全局,所以不会将其"回收". 只要你不停的向一个list/vector容器添加元素... 

>[!warning] 不可避免的开销
不管何种垃圾回收算法,都要判断一个问题: 
>>[!faq] 这块内存什么时候可以回收? 
>实现引用计数器也好,进行有向图的遍历也罢,这些都需要引入额外的操作,最为"致命"的是,进行上述操作时,通常需要STD(stop the world),对于一些实时性要求非常高的系统,几乎是不可接受的. 

手动管理内存将这个问题交给了"苦逼"的程序员,所以程序在运行时就不需要关心这个问题了. 并且可以将内存回收进行调控,内存回收更加迅捷,即使两个程序的峰值内存占用相差无几,手动管理内存可以做到尽可能短的峰值内存占用. 

该图片只是为了表达含义,无具体实验科学依据. 

![](jit_and_aot-20240124152043173.webp)

有的人或许会跳出来说,现在的gc算法非常优秀了,已经可以做到延迟非常短了,几乎可以忽略不记了. 

我这里是想强调,gc就是会存在比手动回收更多运行开销,这是不可避免的.你gc算法性能再优秀,也还是有开销,并且其实这部分开销其实挺大的. 而且我想吐槽一点, 很多算法看上去性能非常好,很大一部分提升来自于硬件性能的提升. 14900k和i5 4690f的性能差多少呢?  

简单总结一下, 手动管理内存将判断内存何时释放这个任务交给了程序员,使得程序得到了下面的好处. 
1. 更小的运行时. 无须携带垃圾回收程序,无限判断内存何时回收.   
2. 更低的时延. 避免了触发垃圾回收时的STD. 
坏处 : 程序员需要更加小心,更多的心智负担,新手更容易写出"糟糕"的程序. 

这样好像有贬低垃圾回收的感觉,让我们换一种表述方式 : 垃圾回收的存在让程序员可以将大部分精力放到具体算法的实现上,提高了开发效率,只是牺牲了一部分的性能和内存(占用时间). 

至少从现实世界来看,带gc的编程语言占据了市场主流,看来很多时候,人们是可以为了便捷性放弃一部分性能的,只要程序的性能不是过于恶劣,以至于无法工作.   

## 2. 泛型 

这是一个很复杂的话题,我不认为我讲得足够好,只是一点点愚见. 

泛型的实现有很多,这里就只讨论一下C++. 
大致原理 : compiler 检查对于模板函数的调用代码, 根据其类型生成对应的函数. 

换言之,和你手写同名函数的最终效果是一致的. 

![](jit_and_aot-20240123154331824.webp)

我时常在想template真的帮助我少写代码了吗? 以上面的mymax为例, 运算符 > 本身就支持数值类型之间的比较. 对于字符串之间的比较,我能想到的实际场景是,两个字符串数进行比较 例如 '1234'和'999'进行比较, 很不幸的是 `>` 默认进行字典序之间的比较,会认为 '999' 大于 '1234' -- 你会发现很多时候你需要 specialization , 为特殊的类型编写代码,可能是去实现一个特殊的mymax也可能是去重载运算符,你会发现哪些重要的,需要特别注意的部分的代码,你是很难少写的. 

更为要命的是,一旦template和例如重载运算符等其他语法结合起来后,导致你很难直接看出来其逻辑, a+b到底执行了什么逻辑,只有天知道. 模板的报错更是令人费解,有时一个错误,几万个报错. 

总体上来说 : 我还是非常欣赏template的. 属于是我即不会用也用不上,但是非常好的特性. 增加一点点编译时间,带来了非常多的便利. 不过代码的抽象程度是实实在在上升了.

>我对于C++的理解不过盲人摸象,存在错误之处还希望指出. 


## 3.第三方库 

阿,第三方库还要批评的吗? 

不可否认,大量的开源库使得我们可以避免重复重复造轮子,提高开发效率. 可以说没有广大开源工作者,今天的软件世界绝对不会如此繁荣. 

但是我是想说,

1. 繁重的依赖,有的时候你只是需要解决一个非常简单的问题,引入了一个重量级的库. 大部分情况下我们都只是需要使用其解决一个小问题. 非常典型的例子就是js的lodash,并不是想说这个库不好,而是有的人只是为了遍历一个数组就引用了 ... 类似的例子还有非常多,我就不一一举例了
2. 人人都是高性能,个个都是大而全. 几乎任何一个库都会标榜自己是 high performance,确实有的库代码并不多,并且实现非常巧妙,性能非常优秀. 且先不说高性能和功能齐全是否冲突. 至少我们说的高性能应该有一个对比的对象,不能和 "虚空" 比性能吧. 有的库即使提供了benchmark,利用一些特殊场景下的测试提高测试成绩,并且只要有一个版本领先于其他类似的库,就可以一直吹嘘自己的高性能,大家都是开源的库,你优秀的算法被他人借鉴学习后,你的优势真的可以一直保持吗? 会不会下一个版本就是其他库的性能更好了呢? 

其实我并不是不喜欢第三方库的使用,而是不喜欢对于第三库的滥用. 一个quick start可能确实可以解决的你的问题,但是是不是会带来更多的问题就说不准了. 

一个笑话: 
vue和react有非常好的性能因为他们使用虚拟dom,而不是直接修改dom,加上diff算法的优化...
Svelte有非常好的性能是因为没有虚拟dom...  

感兴趣的人可以更加深入了解一下,你会发现vue和svelte的性能差距在不同场景下是不同的,仅凭一个"hello world"就断定谁谁性能更好是不理智的行为.  


### 总结 

1. 争吵是没有意义的. 因为发生争吵的前提就是对方无法理解和认可对方. 
2. 没有银弹. 勤勤恳恳地把代码一点点写好才是我们应该考虑的事情. 
3. 你"浪费"在代码上的每一分每一秒都是有意义和有价值的. 