---
file-created: 2023 11 25
last-modified: 2023 11 29
---

我们接触不到的,但是可以看一看
有多少代码它们最后的优化结果可能是完全一致的呢? 我不知道就是说 哎, 还是太令人难过了不是吗? 哈哈哈哈 其实也不是很缺人的就是说 大数据开发 

我还是喜欢高一些自己的东西和内容 可以现在展示一下自己的积累  错了 其实你没有任何的积累,都是一些没有价值的内容和东西




常量折叠（Constant Folding）：将程序中的常量表达式计算为一个常量值，以减少运行时的计算量。

常量传播（Constant Propagation）：在编译时将已知的常量值传播到其它表达式中，以减少运行时的计算量。

死代码消除（Dead Code Elimination）：移除不会影响程序输出的无用代码，如未使用的变量或无法到达的代码块。

循环展开（Loop Unrolling）：将循环体复制多次，减少循环次数，以提高性能。

函数内联（Function Inlining）：将函数调用替换为函数体代码，以减少函数调用开销。

公共子表达式消除（Common Subexpression Elimination）：消除表达式中的重复计算，将结果存储并复用。

强度削弱（Strength Reduction）：用较低复杂度的操作替换高复杂度的操作，如用位移操作替换乘法操作。

指令调度（Instruction Scheduling）：对指令进行重新排序，以提高指令流水线利用率和减少等待时间。

分支预测优化（Branch Prediction Optimization）：优化分支指令，减少分支预测错误带来的性能损失。

尾递归优化（Tail Recursion Optimization）：将尾递归调用转换为迭代，以减少栈空间使用和函数调用开销。

逃逸分析（Escape Analysis）：分析对象的作用范围，将堆上的对象分配转移到栈上，减少内存管理开销。

向量化（Vectorization）：将多个独立的操作合并为单个 SIMD（单指令多数据）指令，以提高并行性能。

函数/变量分离（Function/Variable Splitting）：将大型函数或变量拆分为更小的部分，以提高缓存利用率和可读性。

无关代码移动（Code Motion）：将循环内不依赖于循环变量的计算移动到循环外，以减少重复计算。




## 为什么不要过早优化

1. 提高开发效率.时间就是金钱.
2. 可能目前阶段的性能就已经可以满足预期了. 你只有先有了一个明确的性能指标要求才是有意义的.
3. 只有足够的运行数据后才可以进行正确高效的优化.抛开实际场景的优化没有意义.比如花费了大量时间去优化不常用的接口.
4. 编译优化的结果很难预测.

## 两段代码谁更快

其实你会发现这两段代码写的都是有"问题"的代码,比如外层循环就没有任何意义.实例1代码利用for为buffer初始化,实例2利用memset进行赋值.

其实应该是

`````col
````col-md
flexGrow=1
===
```cpp
void Example1(){
	char buffer[1024];
	constexpr  int loop_times = 1000000;
	auto start = std::chrono::high_resolution_clock::now();
	for (int i = 0; i < loop_times; i++) {
		for (int j = 0; j < sizeof (buffer);++j) {
			buffer[j] = 0;
		}
	}
	auto end = std::chrono::high_resolution_clock::now();
	std::cout << "Cost Time: " << std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count() << "ns" << std::endl;
}
```
````
````col-md
flexGrow=1
===
```cpp
void Example2(){
	char buffer[1024];
	constexpr  int loop_times = 1000000;
	auto start = std::chrono::high_resolution_clock::now();
	for (int i = 0; i < loop_times; i++) {
		// 一次给整个数组长度的空间赋值 0
		memset(buffer, 0, sizeof(buffer));
	}
	auto end = std::chrono::high_resolution_clock::now();
	std::cout << "Cost Time: " << std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count() << "ns" << std::endl;
}
```
````
`````
我将会在不同的编译优化等级编译然后运行.

这里不光是需要设计编译优化的等级 我们还是需要针对不同长度的buffer进行操作,这样才能更好的体现其性能.同时也应该多次运行该程序然后获取其平均运行时间.

