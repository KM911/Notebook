---
file-created: 2023 11 04
last-modified: 2023 11 26
---

>[!faq] 我们为什么要并发 ? 
>提升性能?如果单线程更快呢?

>[!note] 因为必须确保多线程并发安全,而不得使用锁带来的额外开销,导致性能不如单线程版本. 

> [!error]- 这个例子非常极端,只是为了说明多线程未必比单线程快
>```go
>func BenchmarkSingle(b *testing.B) {
>	sum = 0
>	lock = sync.Mutex{}
>	wait = sync.WaitGroup{}
> 	for i := 0; i < b.N; i++ {
> 		sum++
> 	}
> 	assert.True(b, sum == b.N)
> }
>
> //这里是在并行
> func BenchmarkMutil(b *testing.B) {
> 	sum = 0
> 	lock = sync.Mutex{}
> 	wait = sync.WaitGroup{}
> 	b.RunParallel(func(pb *testing.PB) {
> 		for pb.Next() {
> 			lock.Lock()
> 			sum++
> 			lock.Unlock()
> 		}
> 	})
> 	assert.True(b, sum == b.N)
> }
>```
>>[!note] Result
>```bash
BenchmarkSingle
BenchmarkSingle-12      1000000000               0.2577 ns/op
BenchmarkMutil
BenchmarkMutil-12       25948872                46.50 ns/op
>```

>[!warning] 甚至多处理器的调度也会导致你的程序性能变差. 

>[!example]- 多线程 ++
>```c
>#include <stdio.h>
#include <pthread.h>
> 
> #define  N 10000000
> long sum = 0;
> 
> void Add(){
>   int i;
>   for(i = 0; i < N; i++){
>     asm volatile("lock addl $1, %0" : "=m"(sum) : "m"(sum));
>   }
> }
> 
> int main(){
>   pthread_t thread_group[4];
>   for (int i = 0; i < 4; i++){
>     pthread_create(&thread_group[i], NULL, (void*)Add, NULL);
>   }
> 
>   for (int i = 0; i < 4; i++){
>     pthread_join(thread_group[i], NULL);
>   }
> 
>   printf("sum = %ld\n", sum);
>   return 0;
> }
>```

>[!example]- taskset 绑定处理器 
> ```bash
> $ time ./a.out
> sum = 40000000
> 
> real    0m0.542s
> user    0m2.047s
> sys     0m0.000s
> $ time taskset -c 0 ./a.out
> sum = 40000000
> 
> real    0m0.085s
> user    0m0.066s
> sys     0m0.011s
> $ time taskset -c 0,1 ./a.out
> sum = 40000000
> 
> real    0m0.509s
> user    0m0.999s
> sys     0m0.000s
> ```
> 
> 


>[!tip] 工程学一切都靠实际说话
>我们通过上面两个例子说明了,你必须考虑全部的情况,才可以获得好的效果. 理论上的好,还不够好. 
