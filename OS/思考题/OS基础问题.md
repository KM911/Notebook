
## OS基础问题

#### 1.为什么c语言中为什么是int main ?

两个方面的解释 

错误处理，通过其返回值，我们可以知道一个函数是否执行成功，比如在字符串中获取子串的位置，当子串不在其中时，返回负值。 
通过main函数的返回值，解决了子进程调用是否成功的问题。很多shell都会读取该值，然后现实对应的提示符类型。

从操作系统的角度，linux上对于线程/进程的抽象是task__struck,其中定义了一个int exit-code，既然操作系统定义为int，我们编写程序肯定就要遵守其规则。所以是int。

可以继续问： 那么操作系统的main函数返回值类型是什么呢？

linux的是void，因为操作系统理论上是不可以挂掉的。 就算挂了，也没有其他的程序可以获取它的返回值。类似的，很多单片机就没有操作系统，编写程序时也是void。


#### 2. 进程上下文切换，切换的内容到底是什么？可以具体讲一下吗？

先从一个high level说明一下，上下文切换，就是恢复进程的执行状态，主要CPU寄存器的内容，因为程序大部分内存比如指令，全局变量都是存放到内存中的，唯一变化的其实就是寄存器中的信息。举个例子，A进程进行了数组的初始化，寄存器中存储的全部都是数组的值，下一步操作是读取数组值并进行计算，这个时候发生了进程切换，B进程的命令是将rax中的值加到rbx中并读取rbx，这里如果不把上一个进程的寄存器信息保存，切换到下一个进程的信息，就会出现完全错误的结果。

因为CPU只会呆呆的执行指令，这里的上下文切换指令是操作系统实现的。

具体到细节，以linux系统为例子，其中的tty 就是进程的执行状态，也就是说，每次操作系统处理中断进行上下文切换时就会去将task_struct中的tty 对应寄存器的值，

同时这里其实也解释了为什么我们说线程比进程切换的上下文开销比较小，其实这里看来好像没有差别，至少我觉得在linux上，没有所谓的进程和线程的区别。

https://linux-kernel-labs.github.io/refs/heads/master/so2/index.html 

这里有非常多的内容其实，都是非常好的学习资料。

https://docs.kernel.org/process/index.html

linux kernel community is really help， it will teach how to understand it.


>[!v] 我想说 : 1. Linux中并没有 "线程" , 或者说操作系统层面, 线程和进程是一致的都是`task_struct`, 用`pid` 和 `tgid` 来区分其线程所属的进程. 
>既然如此,在Linux上,线程的context switch 和 线程的就不应该有太多性能差距. 



#### 3. 关于fork 和 evecve ？ 

如果你理解了状态机其实就是好理解了，fork是将自己复制一份，并且cow，execve是加载一个程序并将状态机重置。 

其实这里我应该想一下 shell是如何实现的，因为其可以加载某个部分的内容，这里使用c来实现其实是比较简单的。


#### 4. 关于segment fault 导致printf无法输出，这里其实就是一个trivial的代码，可以作为一个小实验作为笑话给大家看看。





#### 5. mmap其实我并没有真的使用，或者说，我不知道该如何在其他的编程语言中使用这些linux. 

将磁盘映射为内存,直接来读取,这样速度比传统IO要快. 

光这里是看不出来的,我们需要进行对比才可以知道,或者才可以更好地帮助你理解,


看来大家都是实现的了，只是我们不知道该如何使用sendfile 和 mmap splice。 这里确实可以去使用一下。

TODO

read and send 真的有那梦多的问题吗？  其实都是可以


这里我真的想吐槽，真的有kernel space 和 user space 吗？ 其实我真的好气 ，是不是我又被骗了呢？ 

我不管，我怀疑一切没有代码实现的内容，如果你真的会了一个概念，你就应该知道这些内容，这里说明我开始进行真的思考了， 如何结合linxu syscall 然后才可以写high performance 

我有一个非常呆的想法，如果每一次read操作，没有操作系统接入，我们根本就不可能有page cache 和虚拟内存，因为指令真的会从0x10000这个位置去读取。 

但是这样的性能开销差别也太大了吧。 难怪我们会说 stack 和 heap 存在性能差异。 因为stack肯定是一个好的固定的情况，但是heap可能被移动到磁盘里了。
MMU 是如何知道对应的虚拟内存位置在哪里的？

在没有DMA 之前CPU读取数据和之后完全是不一样的，我的天，我都不敢想那些事情有多复杂。 
ring 0
ring 4 是什么东西，计算机的知识根本是不够的。

java nio  NIO:  New IO

## 其实这里和我们之前说的 减少用户态和内核态的切换其实是一致的，只是当时的我并不知道，那些操作是会导致用户态和内核态的切换。 



内存是虚拟的,那岂不是每一次读取内存中的数据,都需要操作系统的协助?