---
file-created: 2023 10 29
last-modified: 2023 11 26
---
## 高级调度

按照调度算法将处于后被队列中的作业挑几个，分配给它内存，建立相应的PCB（进程的户口），让它们有机会被CPU执行
### PCB

操作系统用它来记录进程的外部特征，描述进程的运动变化过程，也使用它来控制和管理进程，也是系统感知进程存在的唯一标志。

存放着操作系统用于描述进程情况及控制进程运行所需的全部信息。

### 作业

作业就是 一个被提交给操作系统执行的任务或程序

每个作业只会被调入一次，调出一次，而且调出的时候必然是 这个作业执行结束的时候。

## 中级调度

内存不够的时候，可以将某些进程的数据调出到硬盘上去。
等有内存空闲或者进程需要运行时再重新调入，这个时候进程在硬盘上的状态时挂起态，被挂起
进程的 PCB 会组成 挂起队列。  也就是说 PCB 还在内存中。
## 低级调度

从进程就绪队列中挑选一个进程，然后将处理器分配给它 ，频率高

## 调度算法 

>[!error]  了解即可,因为你不能修改操作系统的调度算法,所以对你没有什么帮助. 

>[!info] 调度算法其实就是解决如何"分蛋糕",再好的调度算法也不能提高性能,只能保证公平,在程序的世界里,似乎没有公平的必要,因为就是应该让重要的进程占据更多的资源. 

TODO [2.2\_5\_调度算法（1）\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1YE411D7nH?p=23&vd_source=036ef261e6800ac6f6a743a8d5dce899)
### 如何学习调度算法


核心思想: 

优缺点分析: 是否保证了公平性? 是否存在线程饥饿 (线程长期无法获取资源)

#### 先到先服务 FCFS First Come First Serve 



#### 短作业优先  SPF Shortest 
这里其实就是贪心算法

好处: 保证了等待时间最短,但是会导致长进程饿死.



#### 高响应比优先 HRRN 

相应比 = $\frac{等待时间 + 要求服务时间}{要求服务时间}$ 

避免了饿死,同时也可以一定程度上让

#### 时间片轮转 round-robin

好处: 保证了公平 

缺点: 没有区分紧急程度.频繁地切换会带来一定的性能开销.

优先级

饿死了 


#### 优先级调度 


#### 多级反馈队列

不过现在来看,其实操作系统的调度算法是混合的.



#### 多级队列



### 真实的处理器调度

### Round-robin scheduling

>[!note] "round robin" 算法的具体实现如下：
> 
> 首先，将所有任务按顺序排列。
> 然后，从第一个任务开始，将其分配资源，直到该任务完成或时间片用尽。
> 当第一个任务完成或时间片用尽时，将资源分配给第二个任务，重复步骤 2。
> 以此类推，直到所有任务都得到了分配。

>[!error] 存在的问题 
>>[!note] 背景
>>一个交互式程序,比如`shell`,每次需要的时间片非常短,但是频率很高.
>>一个矩阵计算程序,需要的时间片非常多,但是实时响应要求低. 
>
>你会发现RR,时间片轮询就会导致你的 `shell` 非常卡顿,必须等待时间片到来才可以处理你的请求. 

>[!faq] 如何调整程序的优先级? 
>其实是没有必要的,

### MLFQ 

MLFQ，即多级反馈队列（Multilevel Feedback Queue）

它将所有任务分为多个队列，每个队列都有一个不同的时间片长度。任务首先进入队列 0，在该队列内运行一个时间片。如果任务在时间片内没有完成，它将被转移到队列 1，在该队列内运行一个更长的时间片。以此类推，如果任务在队列 n 内仍然没有完成，它将被移至队列 (n + 1)，在该队列内运行一个更长的时间片。

MLFQ 算法的具体实现如下：

首先，将所有任务按优先级排序。
然后，将所有任务放入队列 0。
从队列 0 开始，为每个任务分配一个时间片。
如果任务在时间片内没有完成，将其转移到下一个队列。
重复步骤 3 和 4，直到所有任务都完成。


存在的问题 : 假如所有的


### CFS Completely Fair Scheduler

vruntime , 尽量保证每一个线程的执行时间是相同的, 不过 nicer 的线程其权重更大,时间流逝更加缓慢. 





## 真实世界的调度 

>[!warning] 
>现实世界的情况总是多种多样,问题没有那么容易解决.

### 优先级反转 
>[!exp]
一个低优先级的线程在持有互斥锁的时候被调度了. 
>```c
>thread_control{ // 最高优先级程序
>     mutex_lock.get()   
> }
>worker {  // 中等优先级
>    do something ...
>}
>
>foo{ // 低优先级程序
>    mutex_lock.get()
>    ...
>    mutex_lock.free()
>}
>
>```
>这将导致高优先级的程序需要等待低优先级程序执行完成后才可以执行-- 和优先级就不正确了. 

### 异构架构 

CPU的每个核心性能未必是一样的. 

并且你还需要考虑非常多的问题, 例如
1. 因为随着功率的提升的,CPU的性能会提高,但是能效未必高,如何尽可能让每个CPU都保持高能效? 让小核高负债其能效未必有大核低负载的能效高. 
2. 需要动态调整CPU的功耗,CPU的性能不是固定的. 
![](进程调度-20240211171037576.webp)


### 多CPU处理器 

高性能服务器主板支持多个CPU,在两个不同的CPU之间进行调度和在CPU内部进行调度???

### CPU热插拔 

太复杂了, 这样你就可以像USB一样,随意增加或者减少CPU. 这样对于服务器维修可太有帮助了. 

### [每个程序员都应该知道的 CPU 知识：NUMA - 知乎](https://zhuanlan.zhihu.com/p/336365600)

每个CPU核心都有自己的cache, 如果随意地将线程进程调度,其性能是非常差的. [多线程多出来的线程真的提高了程序的运行效率吗？](多线程多出来的线程真的提高了程序的运行效率吗？.md)





## 进程同步

由于多道程序的并发执行，所以程序的执行顺序和执行时间是不固定的。

进程的执行并不是一贯到底而是走走停停，因为资源是有限的，速度不可预知，顺序也是。

但是一些工作需要需要进程的相互配合，进程同步就是为了确保多道程序环境下不同进程之间能够正确的，协调地工作，避免冲突和不一致。

## 进程互斥

对临界资源的访问，需要互斥的进行，即同一时间段只能允许一个进程访问该资源。

### 四个部分

* 进入区：检查是否可进入临界区，进入就需要上锁。
* 临界区：访问临界资源的代码
* 退出区：负责解锁
* 剩余区：其余代码

### 原则

* 空闲让进：临界区空闲时，应允许一个进程访问
* 忙则等待：临界区正在被访问时，其他试图访问的进程需要等待
* 有点等待：不能一直让一个进程等着吧，不然饿死了
* 让权等待：进不了临界区，就交出CPU，别忙等
