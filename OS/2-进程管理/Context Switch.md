---
file-created: 2023 10 29
last-modified: 2023 11 26
---

>[!note] Background
> 操作系统里多个程序,但是CPU却只有一个,就算多核处理器通常也只有4-16个核心,和程序的数量相比,不值一提, 我们不得不面临一个情况,就是多个程序共享一个CPU核心.

>[!example] 

这里需要先做一些抽象. 我们假设CPU就只有4个寄存器,是r0-r3,执行下面两个程序的命令. 

定义一下汇编指令. (和真实时间的汇编存在差距,只是为帮助你理解)
movq $r1 $r2 将 r2的值赋值给r1 
addq $r1 $r2  将r2的值添加给r1 
getq $r1 获取r1的值 

我们的CPU基础器当前的值分别为 2 ,5 , 8 , 100. 两个程序的指令分别如下

`````col
````col-md
flexGrow=1
===
```asm
move $0 $1      # $0 = 5
addq $0 $1      # $0 = 10
move $1 $0      # $1 = 10
getq $1         # 获取值为 10
```
````
````col-md
flexGrow=1
===
```asm
move $0 $3      # $0 = 100
addq $0 $3      # $0 = 200
move $3 $0      # $3 = 200
getq $3         # 获取值为 200
```
````
`````

如只执行程序1,获取的值为10, 如果只执行程序2,获取的值为200. 

但是如果在执行程序1的过程中发生了中断,CPU的执行权交给了程序2,会发生什么我都不敢想. 

但是很明显,我们并没有因为发生了进程/线程切换导致程序的运行结果出现问题,肯定存在一种机制确保了进程/线程之间的隔离. 

## 一种可能的方法. 

我们只需要将环境保存不就好了吗? 

新增加两个指令. 
```asm
pushq $0 将r0的值压入栈 
popq $0 弹出栈并将值赋值给r0
```

我们现在就可以定义两个函数, 作用分别是保存全部的寄存器值,和恢复寄存器的值. 
`````col
````col-md
flexGrow=1
===
```asm
pushq $0
pushq $1
pushq $2
pushq $3
```
````
````col-md
flexGrow=1
===
```asm
popq $3
popq $2
popq $1
popq $0
```
````
`````
每次发生进程/线程切换时,我们就执行上面两个函数, 保存前一个寄存器的环境,恢复后者的环境.这样我们就不会因为程序共享CPU而导致程序的运行结果出现错乱,实现了共享和隔离. 

### 一些补充

实际上,真实世界的情况要复杂得多. 因为存在大量的程序,需要有一个合理的栈设计确保不会出溢出,更何况还有可能会不停地创建新地程序,环境更加复杂.如果才可以确保获取的是下一个要切换线程的环境? 可以设计一张跳表 或者 遍历程序栈?   

真实的CPU寄存器数量要更加多,更加复杂. [[x86_64寄存器数量]] , 可能部分寄存器只提供给操作系统使用,各种寄存器的功能也大不相同. 


## 定性分析 

上下文切换肯定会带来额外的开销,并且这部分开销是不可避免的,是为了实现多个程序共享CPU必定会带来的. 

## 定量分析

如果就按照我上面的推断,也就是上下文切换只需要保存全部的寄存器值就好了 ,一个寄存器值8byte,现在随便一个CPU的三级缓存都是MB级别的,所以带来的性能开销其实非常小,我个人认为其实是可以忽略不记的,因为相比之下内存管理,磁盘IO,网络IO所花费的时间才是程序的大头.

## 结论 

上下文切换带来的开销很贵,是因为这是一笔额外的费用,但是其实并不高,对于程序的性能影响其实非常小,真正的耗时操作都是其他的地方. 
