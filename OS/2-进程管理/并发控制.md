---
file-created: 2023 11 01
last-modified: 2023 11 26
---

我们一般讨论的并发编程特指多线程编程,我们基本不涉及进程将通信等问题.

### 何为并发

一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。

#### 高并发

通常是指通过设计保证系统能够同时<font style="color:gold">并行</font> 处理很多请求

并发与高并发   虽然这两个十分相似，但不一样多了，并发是我们操作系统的一个概念，
但是 高并发 在现在却是指代 大流量 超高请求数量的业务场景。

所以才会有什么鬼的  并发量......  ！理解什么意思就可以了，起码别人说的时候不会迷糊。
### 并发的实现 



### 并发导致的问题

1. 竞态条件：当多个线程同时访问共享资源时，可能会出现竞态条件。竞态条件会导致程序的行为不确定，可能会出现意料之外的结果。

2. 死锁：当多个线程相互等待对方释放资源时，可能会出现死锁。死锁会导致程序无法继续执行，需要手动终止程序。

3. 上下文切换开销：当多个线程在同一时间运行时，操作系统需要进行上下文切换，将 CPU 时间片分配给不同的线程。上下文切换会带来一定的开销，可能会影响程序的性能。

4. 调试困难：并发程序的调试比较困难，因为多个线程同时运行，可能会出现难以重现的问题。


### data race 

其实常见的并发bug有两种. 1: 忘记上锁了 2: 上错锁了

```c 
void thread1(){
  pthread_spin_lock(&lock1); 
  cout ++; 
  pthread_spin_unlock(&lock1);
}
void thread2(){
  cout ++; 
}
```

```c
void thread1(){
  pthread_spin_lock(&lock1); 
  cout ++; 
  pthread_spin_unlock(&lock1);
}
void thread2(){
  pthread_spin_lock(&lock2); 
  cout ++; 
  pthread_spin_unlock(&lock2);
}
```



