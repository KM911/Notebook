## 互斥是如何实现的

TODO [2.3\_1\_进程同步、进程互斥\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1YE411D7nH?p=26&vd_source=036ef261e6800ac6f6a743a8d5dce899)
### 硬件实现




### 软件算法实现 

![[Pasted image 20231005142311.webp]]



### 操作系统的互斥算法实现

1. spin_lock自旋锁
2. mutex 睡眠锁
3. futex 两者结合 linux 的syscall 

其他的锁 , 基本上都是基于这两种实现的,

#### spin_lock 自旋锁

```c

```

使用场景: 

1. 临界区不拥堵 == 获取锁的线程很少,发生争抢的情况很少. 
2. 执行的任务耗时短 避免等待的线程长等待
3. 持有自旋锁的线程不应该产生上下文切换,因为如果执行的线程切换了但是还没有释放锁,其他等待线程依然无法工作,会进一步增加耗时.
4. 使用原子指令导致的性能开销
5. 自旋锁的满等待


自旋锁几乎没有什么使用场景. 

最好保证我们的粒度足够小. 


#### mutex 睡眠锁

我们自然就会想到,长时间白白等待肯定是不"明智"的,我们可以借助操作系统的系统调用,将等待的线程进行休眠,等到锁被释放了,就将等待的线程唤醒.

mutex 或者说睡眠锁,这里利用操作系统的systemcall实现的,无法借助应用程序自身实现,因为应用程序不能主动选择自己获取CPU的时间片. 



#### futex 

这里是linux提供的一个系统调用. ? 还是说是一种思想? 



软件不可以 让硬件来解决 
程序无法解决 就让内核来解决

解决问题的方法还有一种,可以解决提出问题的人. 

所以我们以后可以先考虑一下是否可以改写我们的题目.


