---
file-created: 2023 10 29
last-modified: 2023 11 26
---
## 死锁
### 死锁触发的条件


TODO 视频课 [2.4\_1\_死锁的概念\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1YE411D7nH?p=38&vd_source=036ef261e6800ac6f6a743a8d5dce899)  一直到本章结束

死锁就是各个进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进。

而 饥饿 则是长期得不到想要的资源，可能是就绪态也可能是阻塞态 然后嘎 0.o！

死循环：某进程执行过程中一直跳不出某个循环的现象，有时是因为程序逻辑bug导致的，有时是程序员故意设计的。

产生死锁需要同时满足以下条件：
    1. 互斥条件 ：只有对必须互斥使用的资源的争抢才会导致死锁，内存，扬声器等可以让多个进程使用的资源是不会导致死锁的。
    2. 不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放
    3. 请求和保持条件：进程已经保持了至少一个资源，但是还是提出了新的新的资源请求，但是这个新请求的资源又被其他进程占有，这个时候请求进程被阻塞，但是又不释放已经拥有的资源。
    4. 循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求

注意！发生死锁时一定有循环等待，但是发生循环等待时未必发生死锁


1. 预防死锁。破坏死锁产生的四个必要条件中的一个或几个。
2. 避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁。
3. 允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。

### 避免出现死锁

我们知道应该上锁来解决问题,但是不正确的上锁也会导致程序出现bug.

#### 安全序列

所谓安全序列，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态，安全序列可以有很多个。

如果分配了资源之后，系统找不出任何一个安全序列， 系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态，不过我们在分配资源之前总是要考虑到最坏的情况。

<font style="color:red"> 安全状态下的系统一定不会发生死锁</font> 

不安全状态也不一定会发生死锁，因为发生死锁需要四个条件，这四个条件，也不是在一瞬间就完成的。

所以，我们可以在资源分配之前判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求，这也是 “ 银行家算法 ”的核心思想。

#### 银行家算法

检查此次申请是否超过了之前声明的最大需求数
检查此时系统剩余的可用资源是否还能满足这次请求
试探着分配，更改数据结构
用安全性算法检查此次分配是否会导致系统进入不安全状态

安全性算法：
                检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收。
                不断重复上述过程，看最终是否能让所有进程都加入安全序列。








--- 



#### 正确的解决方案 

正确的上锁顺序.

你学操作系统可能会看到很多很扯淡的方法,根据定义去破坏条件,比如消除资源竞争,我就是需要上锁来避免数据竞争,怎么可能消除呢? 

只要全部的线程都保证一个固定的顺序进行上锁就不会出现问题.即使是从中间开始也没有关系.

这个听上去好像有一点点奇怪.  利用递归的思想就好了
定义为 T(A)
T1(A,B) T2(B)


只有一把锁A,谁拿到谁执行,其余等待.
两把锁A,B. 这里需要分情况讨论,需要两把锁才可以执行和只需要其中一把就可以(考虑顺序的话,就是B锁). 


需要两把锁的情况 : 线程先竞争拿A锁,只有拿到A锁的人才可以继续拿B锁,效果和只有一个锁的情况是一致的.


部分线程需要A,B两把锁才可以执行,部分线程只需要B锁就可以执行: 对于只需要B锁就可以执行的线程,他们内部的情况和只有一把锁,对于两者,A锁不会影响T2的运行,T1拿到A锁后,情况变成了只有B锁的情况.


T1(A,B,C) T2(B,C)  T3(C)  L(A,B,C)

T1(A,B,C) T2(A,C)  T3(C)

#### 程序验证

对于只有单一锁的情况还是比较好理解的,我们是否可以借助一些工具帮助我们查看呢? 好吧,我也写不出来非常完美的验证算法.

```python
import copy

def Check(Lock , *Threads):
  lock_list = []
  for t in Threads:
    if t[0] == Lock:
      lock_list.append(True)
    else:
      lock_list.append(False)
  return lock_list

def Display(Lock , *Threads):
  print("锁的状态为",Lock)
  print("线程的状态为")
  for index in range(len(Threads)):
    print(index,Threads[index])
  print("\n")
# 演算一步
def Step(Lock , *Threads):
  thread_lens = len(Threads)
  Display(Lock,*Threads)
  for l in Lock:
    lock_list = Check(l,*Threads)
    for p in range(thread_lens):
      if lock_list[p] == True:
        print("如果分配锁",l,"给线程",p,Threads[p])
        lock_copy = copy.deepcopy(Lock)
        threads_copy = copy.deepcopy(Threads)
        lock_copy.remove(l)
        threads_copy[p].remove(l)
        Display(lock_copy,*threads_copy)
```

```python
L = ["A","B"]
T1 = ["A","B"]
T2 = ["B"]
Step(L,T1,T2)
```

运行结果 : 
```
锁的状态为 ['A', 'B']
线程的状态为
0 ['A', 'B']
1 ['B']


如果分配锁 A 给线程 0 ['A', 'B']
锁的状态为 ['B']
线程的状态为
0 ['B']
1 ['B']


如果分配锁 B 给线程 1 ['B']
锁的状态为 ['A']
线程的状态为
0 ['A', 'B']
1 []
```


结论: 只要保证上锁顺序是固定的,无论从头开始还是中间开始,就可以避免出现死锁的情况.


### 解除死锁

既然已经发生了死锁情况，那不妨根据一种方法，来决定哪个进程将被撤销掉，从而释放它所持有的资源，来让其他进程能够获得，从而解除循环等待。

但是这种方法可能会撤销一个马上就要结束的进程，导致功亏一篑。


还可以对某一个进程进行资源的剥夺，将其拥有的资源分配给其他进程。
