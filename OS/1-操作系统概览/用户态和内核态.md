## 谁的状态?

这里是谁的状态呢? 操作系统的?CPU的? 

我们假设一下,假如一个单核的CPU,一个时间片里只能执行一个任务,如果这里执行了操作系统的任务就无法执行其他的应用程序的命令. (操作系统不是一直在运行的)

我们的CPU又不知道你是操作系统还是其他的应用程序,它只是一个无情的执行指令的机器.如何知道这条指令是操作系统还是应用程序提出呢?应用程序不应该可以随意执行指令.

所以我们不妨就假设CPU某个寄存器的值为1,就是操作系统在执行,为0就是其他应用程序,这样CPU就知道这条指令是否是有权限执行的了.这里就是内核态和用户态.

当操作系统主动让出CPU时,就将该寄存器的设置为0,当发生中段,需要操作系系统介入,就将该寄存器的值设置为1. 中断处理程序也是操作系统提供的.


# 待求证

CPU中真的有一个名为 程序状态字寄存器(PSW),其中有一个二进制位,1表示内核态,0表示用户态.


## 目的?


我们知道,操作系统解决了很多安全问题,比如说向一个磁盘空间里去写入一段数据,这里其实是很危险的,比如你写入的位置是操作系统核心文件,如果没有操作系统的安全检查,你写入成功后,你的系统就可能挂了.

所以就有了用户态和内核态,用户态只能执行"安全"的事情,比如进行运算,将可能存在风险的事情交给操作系统去判断是否安全,如果安全再执行.

比如普通用户是无法访问root创建的文件(不提供root权限的前提下),是因为操作系统做了多用户权限这样的安全功能.并且你会发现,操作系统其实还做了很多事情,比如它需要查看当前文件的所属用户,判断你是否有权限打开该文件,修改文件的最后更新时间.而不是简单地将一段byte array写到磁盘的某一个位置。(感觉操作系统好伟大呀!）

## 代价?

操作系统通过用户态和内核态的隔离,增强了安全性,那么代价是什么呢?

抛开全部的不谈,我们的CPU执行的指令需要比之前多执行几条指令,去修改一个寄存器的状态.

可以可视化一点吗? 好像不太可以.

````col
```col-md
flexGrow=1
===

没有用户态和内核态区分
CPU: 执行程序的指令
```
```col-md
flexGrow=1
===
有用户态和内核态区分
CPU: 执行程序指令 + 用户态和内核态切换指令 + 校验当前是否有权限 
```

````


简单来说就是对于性能存在影响.比如两个操作系统,一个不进行用户权限检查,另一个相反.我们不用想都可以知道前者的性能是更加好的. 类似的内容[[高性能代码]]. 


这里损失的性能是可接受的,实现了权限隔离对于安全非常重要,不然任何的恶意程序都可以随意的控制你的计算机. 

* 损失的性能是可接受范围 
* 确实有多用户的需求 
* 权限隔离对于安全性的提升

这里其实是操作系统的一部分,这里还是比较重要的.

但是不是任何场景下都需要操作系统的


>[!info] 一个嵌入式设备中,就没有多用户的场景,如果可以定制一个操作系统,将多用户机制移除,我相信操作系统的资源占用和性能将会有一定的提升.


### 何时会发生用户态到内核态的切换

1. 使用了系统调用
2. 异常
3. 外部设备中断

或者换句话将,如果当前的操作需要操作系统,你就需要进行切换. 

## 减少性能损失

上面我们提到了进行切换是有性能损失的,如果我们可以通过一些手段来减少用户态和内核态的切换,我们程序的性能将会有所提高.

#### 利用buffer和cache

这里和高性能代码的内容重复了其实.

这里是在进程内部的资源,当然了申请内存其实还是会需要操作系统帮忙,通过修改读cache写buffer,避免直接刷盘,可以减少切换.

这里也其实是一样的,减少频繁的内存申请也可以提高性能,或者说你直接一次性请求大量内存比如多次请求少量的内存效率要高,并且由于是连续内容,你读写速度也会相对应提高一些.



零拷贝技术 难道说 用户态的内容还需要进行拷贝给不是就通过判断一个寄存器的值就可以知道当前是用户态还是内核态吗

零拷贝技术是一种I/O操作优化技术，可以快速高效地将数据从文件系统移动到网络接口，而不需要将其从内核空间复制到用户空间

这里就不是什么所谓的用户态和内核态,理解错了.


我该如何知道自己是否使用了mmp呢? 加上这里我们可能需要设计一个实验了.
