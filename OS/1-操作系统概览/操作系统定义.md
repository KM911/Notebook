---
file-created: Sunday, October ,2023
last-modified: Saturday, November ,2023
---
## 操作系统是什么

>[!note]  一个管理硬件资源和协调其他软件的应用程序

这里有两个重点,分别是管理硬件资源 和 应用程序. 

硬件有很多,比如CPU,内存,硬盘等等,我们不会让其他应用程序自己来使用决定资源的使用,而是让操作系统来决定.不同的软件之间想要"沟通",就需要操作系统来协助,比如杀毒软件可以将病毒程序关闭,如果任意一个程序都可以关闭其他的程序这是非常危险的,这里就需要操作系统来协调.

硬件之上的都是软件,我们的操作系统也是软件,从这个角度来看,我们的`main.exe`和操作系统没有区别,它们都是一个状态机.

>[!question] 补充 现实生活中的操作系统概念要复杂/模糊得多. 就连`现代操作系统`的作者也质问到,操作系统的定义是否应该包含其携带的基础软件,比如win的office. 因为现实生活中我们购买其操作系统,就是为了享受诸如云端同步,人工客服等服务,这些是否也是操作系统的一部分呢? 

## 为什么要学操作系统

>[!info] 我认为,操作系统作为计算机世界的重要组成部分,和各个领域都高度融合.但是我们其实学习的是诸如进程管理,内存管理,文件系统等概念. 既不是让你写操作系统,也不是让你设计更好的算法.而是认识它,认识这个为你编写的软件提供资源的它,了解其各种系统调用的原理,帮助你写出更好的软件. 核心是 : 写出更好的软件. 

操作系统可以说是最复杂的软件了,我们普通软件会遇到的几乎所有问题,你都可以在操作系统上找到类似的解决方案,或者说操作系统提供了一种解决方案. 

总结一些, 学习操作系统不是为了让你造操作系统 ,而是让你了解它,让它更好的和你协作,让你的软件更好的工作. 

## 为什么需要操作系统

操作系统解决了什么问题? 

* 屏蔽底层硬件差异,为软件开发提供便利. 
* 协调程序,实现程序之间的交流.
* 安全监控,将危险操作拒之门外.

不同的产品型号的硬件,可能有不同的协议/接口.如果让每一个软件工程师都要和硬件打交道这是非常低效的.操作系统将底层的硬件细节,为上层软件提供简洁明了的接口. 

我记得看 `<<Just for fun>> `时,liunx买了一块硬盘,第一件事情就是去为其编写驱动.要是没有操作系统和驱动工程师他们提供的驱动,我都不感想象电脑的使用有多么可怕

杀毒软件可以关闭病毒程序;点击一个链接,自动打开浏览器访问;不同程序之间甚至还需要通信(IPC);我们需要debug调试程序,需要将程序停在某个状态,同时将当前程序的信息交给调试程序,比如修改某个变量的值,当前函数调用的堆栈信息... 这些都需要操作系统在其中协调才可以实现.

我们的debug程序可以修改其他程序某个变量的值,这是很危险的!!! 游戏作弊器就可以修改游戏某些关键变量比如金钱,HP的值,就可以让我们获得无穷的"力量". 如果被恶意程序修改/读取了某些变量值,可能发生程序崩溃,隐私安全等问题.

你可以保证多线程下的++运算还正确吗? 很不幸的是 这个无法保证.

```c
#include<stdio.h>
#include<pthread.h>
#include <stdlib.h>

int N = 100000;
int cout = 0;
void add(){
	for(int i = 0; i < N; i++){
			cout ++;
		}
}
int main(int argc, char *argv[]){
		int thread_count = strtol(argv[1], NULL, 10);
		pthread_t *thread_handles;
		thread_handles = malloc(thread_count*sizeof(pthread_t));
		for(int i = 0; i < thread_count; i++){
			pthread_create(&thread_handles[i], NULL, (void *(*)(void *)) add, NULL);
		}
		// join threads
		for(int i = 0; i < thread_count; i++){
			pthread_join(thread_handles[i], NULL);
		}
		printf("cout = %d\n", cout);
		return 0;
}
```

这里有多个原因,因为你没有办法直接去让一个寄存器里的值加

这段代码在不同的优化等级下,结果是会不一样的.

多线程的并发优化反而有你问他 