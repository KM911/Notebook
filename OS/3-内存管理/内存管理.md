## 遇到的问题

1.  内存的分配和回收
2.  虚拟内存
3.  地址重定位 
4.  内存隔离


地址寄存器
## 内存分配和回收 






### 覆盖和交换

* 覆盖技术 

早期计算机内存非常紧缺. 

所以必须需要

* 交换技术 

利用内存和磁盘相互交换,SWAP分区 

* 

### 连续内存分配 

#### 单一连续分配 

只有一个应用程序存在.

微软早期MS-DOS系统. 

吓死人
#### 固定分区分配

多程序出现了. 若干个程序.




#### 动态分区分配

核心重点, 也是现代操作系统的必备.

存在内部碎片,外部碎片多. 


##### 数据结构
如何记录空闲的空间呢? 
* 链表
* 表

#### 动态分区分配算法

动态分区分配算法：在动态分区分配方式中，当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配。


常用的数据结构   ①：空闲分区表  ②：空闲分区链

综合下来  没有亲自测验，首次适应算法最优。

##### 首次适应算法

思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区

如何实现：空闲分区以地址递增的次序排列，每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。

缺点：每次都从链头开始找，那先到先得的进程肯定会占据头部的空间，而且不一定用完，所以就会产生 外部碎片（空间太小，暂时未被利用）

##### 临近适应算法

尽然头部那几个都不一定能用，那么下次分配的时候，就不从头开始，上次查找到哪里，就从这里继续，你可能会问  谁 上次查找到这里，当然是从上一个进程被分配的内存分区开始的。

当然，这样的话，空闲分区依旧需要按照地址递增的顺序排列，但是得称为一个循环的链表，因为头部的也可能是个大的内存分区，不一定被用完。

而且 也不需要对改变后的容量进行排列，因此开销方面优于 下面介绍的两种算法

但是它也是有缺点的，就是如果高地址部分有大分区的话，这些大分区就会被使用，从而转化为小分区，导致需要大内存分区的进程无法使用，毕竟在低地址部分也可能有这些需要内存比较少的进程的一席之地。


##### 最佳适应算法

由于动态分区分配是一种连续分配方式，为各个进程分配的空间必须是连续的一整片区域，因此为了保证当  大进程  到来时 能有连续的大片空间，需要尽可能的留下大片的空闲区，优先使用更小的空闲区。

如何实现：空闲分区按 <font style="color:gold"> 容量</font> 递增次序排列的次序排列，每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。

缺点：会产生较多的外部碎片，因为比较小的空闲分区 有可能一直无法被使用

##### 最坏适应算法

是最佳适应算法的反面，将容量递减来排列

正难则反是吧？ 这样也是不行的，你大容量分区也是有小容量分区组成的，如果到来的进程并不能够恰好装满大分区，它照样会留下外部碎片

而且，当一个进程本身就需要大容量的时候，大容量分区被若干需要小容量进程占据，大进程自然就无法被分配，这也算是一个问题。



## 基本地址变换

基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。
通常会在系统中设置一个页表寄存器(PTR) ，存放页表在内存中的起始地址（始址） F 和
页表长度 M。

进程未执行时，页表的始址和页表长度放在进程控制块(PCB) 中，当进程被调度时，操作系
统内核会把它们放到页表寄存器中。

注意:页面大小是2的整数幂

设页面大小为L，逻辑地址A到物理地址E的变换过程如下:

1. 计算页号P和页内偏移量W (如果用十进制数手算，则P=A/L，W=A%L;但是在计算机实际
运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页
内偏移量)
2. 比较页号p 和 页表长度M，若 P>=M, 则产生越界中断，否则继续执行。
注意：页号是从 0 开始的，但是页表的长度至少是 1，因此 P=M 时 也会越界。

在分页存储管理（页式管理）的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。
因此，页式管理中地址是  一维的。

给一个页面大小，给一个逻辑地址，就能自动算出页号，页内偏移量 两个部分，并不需要告诉操作系统。

![[Pasted image 20231025165323.webp]]


理论上，页表项长度为 3B 即可表示内存块号的范围，但是，为了方便页表的查询，常常会让一个页表项占更多的字节，使得每个页面恰好装的下整数个页表项。




